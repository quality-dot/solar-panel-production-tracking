#!/usr/bin/env node
import {
  InMemoryEventStore,
  proxyServer,
  startHTTPServer
} from "../chunk-JCZNH6HS.js";

// src/bin/mcp-proxy.ts
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { EventSource } from "eventsource";
import { setTimeout } from "timers";
import util from "util";
import yargs from "yargs";
import { hideBin } from "yargs/helpers";

// src/StdioClientTransport.ts
import {
  ReadBuffer,
  serializeMessage
} from "@modelcontextprotocol/sdk/shared/stdio.js";
import { spawn } from "child_process";
import { PassThrough } from "stream";

// src/JSONFilterTransform.ts
import { Transform } from "stream";
var JSONFilterTransform = class extends Transform {
  buffer = "";
  constructor() {
    super({ objectMode: false });
  }
  _flush(callback) {
    if (this.buffer.trim().startsWith("{")) {
      callback(null, Buffer.from(this.buffer));
    } else {
      callback(null, null);
    }
  }
  _transform(chunk, _encoding, callback) {
    this.buffer += chunk.toString();
    const lines = this.buffer.split("\n");
    this.buffer = lines.pop() || "";
    const jsonLines = [];
    const nonJsonLines = [];
    for (const line of lines) {
      if (line.trim().startsWith("{")) {
        jsonLines.push(line);
      } else {
        nonJsonLines.push(line);
      }
    }
    if (nonJsonLines.length > 0) {
      console.warn("[mcp-proxy] ignoring non-JSON output", nonJsonLines);
    }
    if (jsonLines.length > 0) {
      const output = jsonLines.join("\n") + "\n";
      callback(null, Buffer.from(output));
    } else {
      callback(null, null);
    }
  }
};

// src/StdioClientTransport.ts
var StdioClientTransport = class {
  onclose;
  onerror;
  onmessage;
  /**
   * The child process pid spawned by this transport.
   *
   * This is only available after the transport has been started.
   */
  get pid() {
    return this._process?.pid ?? null;
  }
  /**
   * The stderr stream of the child process, if `StdioServerParameters.stderr` was set to "pipe" or "overlapped".
   *
   * If stderr piping was requested, a PassThrough stream is returned _immediately_, allowing callers to
   * attach listeners before the start method is invoked. This prevents loss of any early
   * error output emitted by the child process.
   */
  get stderr() {
    if (this._stderrStream) {
      return this._stderrStream;
    }
    return this._process?.stderr ?? null;
  }
  _abortController = new AbortController();
  _process;
  _readBuffer = new ReadBuffer();
  _serverParams;
  _stderrStream = null;
  onEvent;
  constructor(server) {
    this._serverParams = server;
    if (server.stderr === "pipe" || server.stderr === "overlapped") {
      this._stderrStream = new PassThrough();
    }
    this.onEvent = server.onEvent;
  }
  async close() {
    this.onEvent?.({
      type: "close"
    });
    this._abortController.abort();
    this._process = void 0;
    this._readBuffer.clear();
  }
  send(message) {
    return new Promise((resolve) => {
      if (!this._process?.stdin) {
        throw new Error("Not connected");
      }
      const json = serializeMessage(message);
      if (this._process.stdin.write(json)) {
        resolve();
      } else {
        this._process.stdin.once("drain", resolve);
      }
    });
  }
  /**
   * Starts the server process and prepares to communicate with it.
   */
  async start() {
    if (this._process) {
      throw new Error(
        "StdioClientTransport already started! If using Client class, note that connect() calls start() automatically."
      );
    }
    return new Promise((resolve, reject) => {
      this._process = spawn(
        this._serverParams.command,
        this._serverParams.args ?? [],
        {
          cwd: this._serverParams.cwd,
          env: this._serverParams.env,
          shell: this._serverParams.shell ?? false,
          signal: this._abortController.signal,
          stdio: ["pipe", "pipe", this._serverParams.stderr ?? "inherit"]
        }
      );
      this._process.on("error", (error) => {
        if (error.name === "AbortError") {
          this.onclose?.();
          return;
        }
        reject(error);
        this.onerror?.(error);
      });
      this._process.on("spawn", () => {
        resolve();
      });
      this._process.on("close", (_code) => {
        this.onEvent?.({
          type: "close"
        });
        this._process = void 0;
        this.onclose?.();
      });
      this._process.stdin?.on("error", (error) => {
        this.onEvent?.({
          error,
          type: "error"
        });
        this.onerror?.(error);
      });
      const jsonFilterTransform = new JSONFilterTransform();
      this._process.stdout?.pipe(jsonFilterTransform);
      jsonFilterTransform.on("data", (chunk) => {
        this.onEvent?.({
          chunk: chunk.toString(),
          type: "data"
        });
        this._readBuffer.append(chunk);
        this.processReadBuffer();
      });
      jsonFilterTransform.on("error", (error) => {
        this.onEvent?.({
          error,
          type: "error"
        });
        this.onerror?.(error);
      });
      if (this._stderrStream && this._process.stderr) {
        this._process.stderr.pipe(this._stderrStream);
      }
    });
  }
  processReadBuffer() {
    while (true) {
      try {
        const message = this._readBuffer.readMessage();
        if (message === null) {
          break;
        }
        this.onEvent?.({
          message,
          type: "message"
        });
        this.onmessage?.(message);
      } catch (error) {
        this.onEvent?.({
          error,
          type: "error"
        });
        this.onerror?.(error);
      }
    }
  }
};

// src/bin/mcp-proxy.ts
util.inspect.defaultOptions.depth = 8;
if (!("EventSource" in global)) {
  global.EventSource = EventSource;
}
var argv = await yargs(hideBin(process.argv)).scriptName("mcp-proxy").command("$0 <command> [args...]", "Run a command with MCP arguments").positional("command", {
  demandOption: true,
  describe: "The command to run",
  type: "string"
}).positional("args", {
  array: true,
  describe: "The arguments to pass to the command",
  type: "string"
}).env("MCP_PROXY").parserConfiguration({
  "populate--": true
}).options({
  debug: {
    default: false,
    describe: "Enable debug logging",
    type: "boolean"
  },
  endpoint: {
    describe: "The endpoint to listen on",
    type: "string"
  },
  gracefulShutdownTimeout: {
    default: 5e3,
    describe: "The timeout (in milliseconds) for graceful shutdown",
    type: "number"
  },
  host: {
    default: "::",
    describe: "The host to listen on",
    type: "string"
  },
  port: {
    default: 8080,
    describe: "The port to listen on",
    type: "number"
  },
  server: {
    choices: ["sse", "stream"],
    describe: "The server type to use (sse or stream). By default, both are enabled",
    type: "string"
  },
  shell: {
    default: false,
    describe: "Spawn the server via the user's shell",
    type: "boolean"
  },
  sseEndpoint: {
    default: "/sse",
    describe: "The SSE endpoint to listen on",
    type: "string"
  },
  stateless: {
    default: false,
    describe: "Enable stateless mode for HTTP streamable transport (no session management)",
    type: "boolean"
  },
  streamEndpoint: {
    default: "/mcp",
    describe: "The stream endpoint to listen on",
    type: "string"
  }
}).help().parseAsync();
if (!argv.command) {
  throw new Error("No command specified");
}
var finalCommand = argv.command;
var finalArgs = argv["--"] || argv.args;
var connect = async (client) => {
  const transport = new StdioClientTransport({
    args: finalArgs,
    command: finalCommand,
    env: process.env,
    onEvent: (event) => {
      if (argv.debug) {
        console.debug("transport event", event);
      }
    },
    shell: argv.shell,
    // We want to passthrough stderr from the MCP server to enable better debugging
    stderr: "inherit"
  });
  await client.connect(transport);
};
var proxy = async () => {
  const client = new Client(
    {
      name: "mcp-proxy",
      version: "1.0.0"
    },
    {
      capabilities: {}
    }
  );
  await connect(client);
  const serverVersion = client.getServerVersion();
  const serverCapabilities = client.getServerCapabilities();
  console.info("starting server on port %d", argv.port);
  const createServer = async () => {
    const server2 = new Server(serverVersion, {
      capabilities: serverCapabilities
    });
    proxyServer({
      client,
      server: server2,
      serverCapabilities
    });
    return server2;
  };
  const server = await startHTTPServer({
    createServer,
    eventStore: new InMemoryEventStore(),
    host: argv.host,
    port: argv.port,
    sseEndpoint: argv.server && argv.server !== "sse" ? null : argv.sseEndpoint ?? argv.endpoint,
    stateless: argv.stateless,
    streamEndpoint: argv.server && argv.server !== "stream" ? null : argv.streamEndpoint ?? argv.endpoint
  });
  return {
    close: () => {
      return server.close();
    }
  };
};
var createGracefulShutdown = ({
  server,
  timeout
}) => {
  const gracefulShutdown = () => {
    console.info("received shutdown signal; shutting down");
    server.close();
    setTimeout(() => {
      process.exit(1);
    }, timeout).unref();
  };
  process.once("SIGTERM", gracefulShutdown);
  process.once("SIGINT", gracefulShutdown);
  return () => {
    server.close();
  };
};
var main = async () => {
  try {
    const server = await proxy();
    createGracefulShutdown({
      server,
      timeout: argv.gracefulShutdownTimeout
    });
  } catch (error) {
    console.error("could not start the proxy", error);
    setTimeout(() => {
      process.exit(1);
    }, 1e3);
  }
};
await main();
//# sourceMappingURL=mcp-proxy.js.map